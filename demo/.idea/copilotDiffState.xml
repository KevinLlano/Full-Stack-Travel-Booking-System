<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/fix-foreign-keys.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fix-foreign-keys.sql" />
              <option name="originalContent" value="-- Fix Foreign Key Constraints to Enable Cascading Deletes&#10;-- Run this script in MySQL to allow customer deletion&#10;&#10;USE full-stack-ecommerce;&#10;&#10;-- First, let's see what foreign keys reference customers&#10;SELECT &#10;    TABLE_NAME,&#10;    COLUMN_NAME,&#10;    CONSTRAINT_NAME,&#10;    REFERENCED_TABLE_NAME,&#10;    REFERENCED_COLUMN_NAME&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE REFERENCED_TABLE_NAME = 'customers' &#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce';&#10;&#10;-- The most likely foreign key causing the issue is in the carts table&#10;-- Let's check the current foreign key constraint on carts.customer_id&#10;&#10;SHOW CREATE TABLE carts;&#10;&#10;-- Drop the existing foreign key constraint (replace 'fk_constraint_name' with actual name)&#10;-- Common names might be: carts_ibfk_1, fk_carts_customer_id, etc.&#10;-- You'll need to replace the constraint name below with the actual one from SHOW CREATE TABLE&#10;&#10;-- Example (replace with actual constraint name):&#10;-- ALTER TABLE carts DROP FOREIGN KEY carts_ibfk_1;&#10;&#10;-- Add the foreign key back with CASCADE DELETE&#10;-- ALTER TABLE carts &#10;-- ADD CONSTRAINT fk_carts_customer_id &#10;-- FOREIGN KEY (customer_id) REFERENCES customers(customer_id) &#10;-- ON DELETE CASCADE ON UPDATE CASCADE;&#10;&#10;-- If there are other tables referencing customers, repeat the process:&#10;-- Check cart_items table if it has direct reference to customers&#10;SHOW CREATE TABLE cart_items;&#10;&#10;-- Also check if there are any other tables that might reference customers&#10;SELECT &#10;    TABLE_NAME,&#10;    COLUMN_NAME,&#10;    CONSTRAINT_NAME,&#10;    REFERENCED_TABLE_NAME&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE REFERENCED_TABLE_NAME = 'customers'&#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce';&#10;&#10;-- After running the above queries, you'll see the constraint names&#10;-- Then uncomment and modify the ALTER TABLE statements below:&#10;&#10;/*&#10;-- Example for carts table (replace constraint name):&#10;ALTER TABLE carts DROP FOREIGN KEY your_actual_constraint_name_here;&#10;ALTER TABLE carts &#10;ADD CONSTRAINT fk_carts_customer_id &#10;FOREIGN KEY (customer_id) REFERENCES customers(customer_id) &#10;ON DELETE CASCADE ON UPDATE CASCADE;&#10;&#10;-- If cart_items also references customers directly:&#10;ALTER TABLE cart_items DROP FOREIGN KEY your_cart_items_constraint_name_here;&#10;ALTER TABLE cart_items &#10;ADD CONSTRAINT fk_cart_items_customer_id &#10;FOREIGN KEY (customer_id) REFERENCES customers(customer_id) &#10;ON DELETE CASCADE ON UPDATE CASCADE;&#10;*/&#10;" />
              <option name="updatedContent" value="-- Fix Foreign Key Constraints to Enable Cascading Deletes for Customer Deletion&#10;-- Run this script in MySQL Workbench or command line&#10;&#10;USE full-stack-ecommerce;&#10;&#10;-- Step 1: Find all foreign key constraints referencing customers table&#10;SELECT &#10;    TABLE_NAME,&#10;    COLUMN_NAME,&#10;    CONSTRAINT_NAME,&#10;    REFERENCED_TABLE_NAME,&#10;    REFERENCED_COLUMN_NAME&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE REFERENCED_TABLE_NAME = 'customers' &#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce';&#10;&#10;-- Step 2: Show current table structures to see constraint names&#10;SHOW CREATE TABLE carts;&#10;&#10;-- Step 3: Fix the most likely constraint - carts.customer_id&#10;-- Try the most common constraint names (one of these should work):&#10;&#10;-- Option A: Common auto-generated name&#10;SET @sql = NULL;&#10;SELECT CONCAT('ALTER TABLE carts DROP FOREIGN KEY ', CONSTRAINT_NAME, ';')&#10;INTO @sql&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE TABLE_NAME = 'carts' &#10;  AND COLUMN_NAME = 'customer_id' &#10;  AND REFERENCED_TABLE_NAME = 'customers'&#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce'&#10;LIMIT 1;&#10;&#10;-- Execute the drop statement if constraint exists&#10;SET @sql = IFNULL(@sql, 'SELECT &quot;No carts foreign key found&quot; as message;');&#10;PREPARE stmt FROM @sql;&#10;EXECUTE stmt;&#10;DEALLOCATE PREPARE stmt;&#10;&#10;-- Add the new constraint with CASCADE&#10;ALTER TABLE carts &#10;ADD CONSTRAINT fk_carts_customer_cascade &#10;FOREIGN KEY (customer_id) REFERENCES customers(customer_id) &#10;ON DELETE CASCADE ON UPDATE CASCADE;&#10;&#10;-- Step 4: Check if cart_items also directly references customers&#10;-- (Some designs have cart_items -&gt; customers, others go cart_items -&gt; carts -&gt; customers)&#10;SELECT COUNT(*) as cart_items_references_customers&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE TABLE_NAME = 'cart_items' &#10;  AND COLUMN_NAME = 'customer_id' &#10;  AND REFERENCED_TABLE_NAME = 'customers'&#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce';&#10;&#10;-- If cart_items directly references customers, fix that too&#10;SET @sql2 = NULL;&#10;SELECT CONCAT('ALTER TABLE cart_items DROP FOREIGN KEY ', CONSTRAINT_NAME, ';')&#10;INTO @sql2&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE TABLE_NAME = 'cart_items' &#10;  AND COLUMN_NAME = 'customer_id' &#10;  AND REFERENCED_TABLE_NAME = 'customers'&#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce'&#10;LIMIT 1;&#10;&#10;-- Execute if constraint exists&#10;SET @sql2 = IFNULL(@sql2, 'SELECT &quot;No cart_items-&gt;customers foreign key found&quot; as message;');&#10;PREPARE stmt2 FROM @sql2;&#10;EXECUTE stmt2;&#10;DEALLOCATE PREPARE stmt2;&#10;&#10;-- Add cascade constraint for cart_items if it was referencing customers directly&#10;-- Note: This will only run if there was actually a constraint to drop&#10;SET @add_cart_items_fk = (&#10;    SELECT COUNT(*) &#10;    FROM INFORMATION_SCHEMA.COLUMNS &#10;    WHERE TABLE_NAME = 'cart_items' &#10;      AND COLUMN_NAME = 'customer_id' &#10;      AND TABLE_SCHEMA = 'full-stack-ecommerce'&#10;);&#10;&#10;-- Only add if customer_id column exists in cart_items&#10;SET @sql3 = CASE &#10;    WHEN @add_cart_items_fk &gt; 0 THEN &#10;        'ALTER TABLE cart_items ADD CONSTRAINT fk_cart_items_customer_cascade FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE ON UPDATE CASCADE;'&#10;    ELSE &#10;        'SELECT &quot;cart_items does not directly reference customers - this is normal&quot; as message;'&#10;END;&#10;&#10;PREPARE stmt3 FROM @sql3;&#10;EXECUTE stmt3;&#10;DEALLOCATE PREPARE stmt3;&#10;&#10;-- Step 5: Verify the changes&#10;SELECT &#10;    'After changes:' as status,&#10;    TABLE_NAME,&#10;    COLUMN_NAME,&#10;    CONSTRAINT_NAME,&#10;    REFERENCED_TABLE_NAME,&#10;    REFERENCED_COLUMN_NAME&#10;FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &#10;WHERE REFERENCED_TABLE_NAME = 'customers' &#10;  AND TABLE_SCHEMA = 'full-stack-ecommerce';&#10;&#10;-- Show the new constraint details&#10;SELECT &#10;    CONSTRAINT_NAME,&#10;    UPDATE_RULE,&#10;    DELETE_RULE&#10;FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS &#10;WHERE CONSTRAINT_SCHEMA = 'full-stack-ecommerce' &#10;  AND REFERENCED_TABLE_NAME = 'customers';&#10;&#10;SELECT 'Foreign key constraints have been updated to CASCADE on DELETE' as result;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>